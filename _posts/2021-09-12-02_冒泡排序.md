---
layout: post
read_time: true
show_date: true
title:  Algorithm系列
date:   2021-09-14 9:09 -0600
description: 冒泡排序算法
img: /posts/20210912/background.jpeg
tags: [Algorithm, C]
author: Albert
---
## 冒泡排序算法
上一张我们讲了桶排序这一种快速简单的排序算法，但还是有一个缺点，就是浪费空间。假设这里有3个数 1，500，1324234 这时我们必须要设置1324235个变量而只用到三个，十分浪费空间。  
现在，我们这里有一道题。  
```
有n个学生(n<30),要求按照分数从大到小排序输出。
例如:输入-> 90 小明 86 小华 67 虎虎 100 小张
    输出-> 100 小张 90 小明 86 小华 67 虎虎
```
这里我们就无法使用桶排序了。我们就需要讲到一个新算法**冒泡排序**,冒泡排序算法思路很简单。
```
依次计较相邻的两个数，如果没有按照顺序排列就交换，直到无法比较为止。
```
完整代码实现如下。
```c
#include <stdio.h>


struct student
{
	/* 此结构体用于储存姓名和分数 */
	char name[30];
	int score;
};


int main()
{
	
	struct student a[100],t;
	int n;

	scanf("%d",&n);

	for (int i = 1; i <= n; ++i)
		scanf("%s %d",&a[i].name,&a[i].score);

	//按分数高低进行排序
	for (int i = 1; i <= n-1 ; ++i)
		for (int j = 1; j <= n-1; j++)
			if (a[j].score<a[j+1].score)
				{
					t = a[j]; 
					a[j] = a[j+1]; 
					a[j+1] = t;
				}

	for (int i = 1; i <= n; ++i) //输出人名
		printf("%s\n", a[i].name);

	getchar(); getchar();
	return 0;
}
```  

现在我们已经可以实现题目要求了。
这个算法就像气泡在水里一样向上冒所以叫做冒泡排序，举一个图的例子。
![](..\assets\img\posts\20210914\bubble_sort.gif)  
这个算法可以直观的看到这个算法并不是很快，确实，依次比较非常耗时间，这个算法的时间复杂度为 __O(n^2)__。之后又有很多人尝试去改进该算法，但都以失败告终。  
这里我个人并不推荐这种算法，后面会将一种更快的算法 __快速排序__。