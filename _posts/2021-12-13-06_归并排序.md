---
layout: post
read_time: true
show_date: true
title:  归并排序算法
date:   2021-12-13 21:17 -0600
description: Algorithm系列
img: bg1.png
tags: [Algorithm, C++]
author: Albert
---
## 归并排序
这是我们讲的最后一种排序方法,归并排序.归并排序是建立在归并操作上的一种有效的排序算法,该算法是采用分治法的一个应用.主要思路就是先将无序列分裂成多个子序列,将每个子序列分开排序,最后将已有序的子序列合并.若将两个有序表合并成一个有序表,则称为二路归并.  
例如4个数据排序: 10 4 7 2  
两大步:分解,合并.  
第一步:[10,4],[7,2]  
第二步:[4,10],[2,7]  
第三步:[4,2,7,10]  
第四步:[2,4],[7,10]  
第五步：[2,4,7,10]  

C++代码如下:
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, a[10001], r[10001];
void msort(int s, int t)
{
    if (s == t)
        return; // 只有一个数字,无需排序,直接返回
    int mid = (s + t) / 2;
    msort(s, mid);                 //左边序列
    msort(mid + 1, t);             //右边序列
    int i = s, j = mid + 1, k = s; //合并

    while (i <= mid && j <= t)
    {
        /* 分裂子串 */
        if (a[i] <= a[j])
        {
            r[k] = a[i];
            k++;
            i++;
        }
        else
        {
            r[k] = a[j];
            k++;
            j++;
        }
    }

    while (i <= mid)
    {
        /* 复制左边子列剩余部分 */
        r[k] = a[i];
        k++;
        i++;
    }
    while (j <= t)
    {
        /* 复制右边子列剩余部分 */
        r[k] = a[j];
        k++;
        j++;
    }
    for (int i = s; i <= t; i++)
        a[i] = r[i];
}
int main()
{
    cin >> n;
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    msort(1, n);
    for (int i = 1; i <= n; i++)
        cout << a[i] << " ";
    system("pause");
    return 0;
}
```