---
layout: post
read_time: true
show_date: true
title:  快速排序算法
date:   2021-11-28 16:51 -0600
description: Algorithm系列
img: /posts/20211128/bg1.png
tags: [Algorithm, C++]
author: Albert
---

## 快速排序算法
快速排序算法是对冒泡排序的一种改进.它的基本思想是:通过一趟排序将待排序记录分割成两个独立的部分,其中一部分记录的关键字均比另一部分的关键字笑,则可分别对这两部分记录继续进行排序,以达到整个序列有序.  

这其实是一个递归的过程(自己调用自己),一趟快速排序的实现如下:设置两个指针i,j,它们的初始值为左边最小的,右边最大的,设置中间的分割线为mid,i依次加大到mid,j依次减小到mid,依次交换a[i]的数和a[j]的数,一直递归这两步,直到i>j为止.  
例:6个数字[1,3,2,5,4,6],快速排序如下:  
[1,3,2,5,4,6]  
第一次:[<u>6</u>,3,2,5,4,<u>1</u>]  //目前所有顺序都对  
第二次:[<u>2</u>,3,<u>6</u>],[<u>1</u>,4,<u>5</u>] //分开  
第三次:[2,3,6,1,4,5]  
第三次:[2,3,<u>1</u>,<u>6</u>,4,5]  
第四次:[<u>1</u>,3,<u>2</u>],[<u>5</u>,4,<u>6</u>]  
第五次:[1,2,3,4,5,6] //基准数归位

快速排序实现如下(程序的良好阅读方法是从主程序开始阅读):
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[1001];

void quicksort(int l,int r){
    int i=1,j=r,mid;
    mid=a[(l+r)/2];             //序列中间
    do{
        while (a[i]<mid) i++;   //左半部分,从左往右加
        while (a[j]>mid) j--;   //右半部分,从右往左减
        if (i<=j){
            swap(a[i],a[j]);    //顺序不正确就交换它们
            i++; j--;           //继续下一步
        }
    }while(i<=j);
    if (l<j) quicksort(l,j);    //未到两数边界就递归寻找下一个
    if (i<r) quicksort(i,r);
}

int main(){
    int n; cin>>n;
    for(int i=1;i<=n;i++)
        cin>>a[i];
    quicksort(1,n);             //开始排序
    for(int i=1;i<=n;i++)
        cout<<a[i]<<" ";

    return 0;
}
```