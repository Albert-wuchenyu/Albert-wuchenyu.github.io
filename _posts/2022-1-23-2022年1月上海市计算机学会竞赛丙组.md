## 2022年1月上海市计算机学会竞赛丙组

### T1 三角形的判定

 不想讲。~~(懒)~~

```cpp
#include <iostream>
using namespace std;

int a, b, c;
int main() {
	std::ios::sync_with_stdio(false);                            // 加快cin,cout速度
	cin >> a >> b >> c;
	if (a + b > c && b + c > a && a + c > b) cout << "Valid";    // 两边之和大于第三边
	else cout << "Invalid";

	return 0;
}


```

### T2 星号三角阵(一)

```cpp
#include <iostream>
using namespace std;

int n;
int main() {
	std::ios::sync_with_stdio(false);
	cin >> n;
	for(int i = 1; i <= n ; ++i) {          // 控制行
		for (int j = 1; j <= i; ++j)        // 控制单行个数
			cout << "*";
		cout<<endl;
	}

	return 0;
}

    
```

### T3 匹配括号的判断(栈)

可用 stack 库实现栈，也可以自己实现。

```cpp

```

### T4 走走跳跳(动态规划)

这道题首先想到的就是搜索，每次分两条路径搜索，最终取最大的。**但是**！！！太慢了！！！时间复杂度是 $O(2^n-^1)$超了。

接下来想到的是**记忆化搜索**。用一个数组记录已经走过的点的权值，这样的化可以避免重走，初始都是-1当走到时就更新最大值，再次走到时就直接调用权值。时间复杂度是$O(N^2)$

其实记忆化搜索已经是**动态规划**的一种了。接下来提供一种动态规划的方法:**顺推法**。

___我们不管这一步怎么走，只管前一步怎么走___ 。意思是每一步都是前一步如何走所得来的，取上一步能走的最大值就是这一步的最大值了。

代码如下：

```cpp
#include <iostream>
using namespace std;

int n;
int main() {
    std::ios::sync_with_stdio(false);
    cin >> n;
    int a[n + 10], t[n + 10], F[n + 10];    // F[]记录每一步的最大值
    for (int i = 1; i <= n ; ++i)
        cin >> a[i];
    for (int i = 1; i <= n - 1 ; ++i)
        cin >> t[i];
    F[1] = a[1];                            // F[1]不参与计算
    for (int i = 1; i <= n-1; ++i) {
        F[i] = max(F[i-1], a[t[i]]) + a[i]; // 状态转移方程,选最大路径
    }
    F[n] = a[n];
    int ans = 0;
    for (int i = 0; i <= n; ++i){
        ans = max(ans,F[i]);                // 比较路径
    }
    cout<<ans<<endl;

    return 0;
}
```